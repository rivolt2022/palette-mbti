"""
ÏñºÍµ¥ ÌäπÏßï Î≤°ÌÑ∞ÏóêÏÑú ÏÉâÏÉÅ ÌåîÎ†àÌä∏Î•º ÏòàÏ∏°ÌïòÎäî Î™®Îç∏ ÏÉùÏÑ±
Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Ïã§Ìñâ Í∞ÄÎä•Ìïú TensorFlow.js Î™®Îç∏ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.
"""

import json
import numpy as np
import tensorflow as tf
from tensorflow import keras
import os
import random

def hex_to_rgb_normalized(hex_color):
    """16ÏßÑÏàò ÏÉâÏÉÅÏùÑ 0-1 Î≤îÏúÑÏùò RGB Í∞íÏúºÎ°ú Î≥ÄÌôò"""
    hex_color = hex_color.lstrip('#')
    r = int(hex_color[0:2], 16) / 255.0
    g = int(hex_color[2:4], 16) / 255.0
    b = int(hex_color[4:6], 16) / 255.0
    return [r, g, b]

def load_emotion_color_mapping():
    """Í∞êÏ†ï-ÏÉâÏÉÅ Îß§Ìïë Îç∞Ïù¥ÌÑ∞ Î°úÎìú"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    mapping_path = os.path.join(script_dir, "..", "public", "data", "emotion-color-mapping.json")
    mapping_path = os.path.normpath(mapping_path)
    
    with open(mapping_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def generate_synthetic_face_data(emotion_mapping, num_samples_per_emotion=30):
    """Ìï©ÏÑ± ÏñºÍµ¥ ÌäπÏßï Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±"""
    X = []  # 128Ï∞®Ïõê ÏñºÍµ¥ ÌäπÏßï Î≤°ÌÑ∞
    y = []  # 15Ï∞®Ïõê RGB Î≤°ÌÑ∞ (5Í∞ú ÏÉâÏÉÅ √ó 3Í∞ú RGB)
    emotions = []  # Í∞êÏ†ï ÎùºÎ≤®
    
    for emotion_name, emotion_data in emotion_mapping['emotions'].items():
        print(f"üìä {emotion_data['name']} Í∞êÏ†ï Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± Ï§ë...")
        
        for i in range(num_samples_per_emotion):
            # 1. 128Ï∞®Ïõê ÏñºÍµ¥ ÌäπÏßï Î≤°ÌÑ∞ ÏÉùÏÑ± (Ï†ïÍ∑úÎ∂ÑÌè¨ Í∏∞Î∞ò)
            # Í∞Å Í∞êÏ†ïÎ≥ÑÎ°ú ÌäπÏ†ï Ìå®ÌÑ¥ÏùÑ Í∞ÄÏßÑ ÌäπÏßï Î≤°ÌÑ∞ ÏÉùÏÑ±
            face_vector = generate_emotion_based_face_vector(emotion_name, emotion_data)
            
            # 2. Í∞êÏ†ïÏóê ÎßûÎäî ÏÉâÏÉÅ ÌåîÎ†àÌä∏ ÏÑ†ÌÉù
            base_palette = random.choice(emotion_data['basePalettes'])
            
            # 3. ÏÉâÏÉÅ ÌåîÎ†àÌä∏Î•º 15Ï∞®Ïõê RGB Î≤°ÌÑ∞Î°ú Î≥ÄÌôò
            rgb_vector = []
            for color in base_palette:
                rgb = hex_to_rgb_normalized(color)
                rgb_vector.extend(rgb)
            
            # 4. ÏÉâÏÉÅ Î≤°ÌÑ∞Ïóê ÏïΩÍ∞ÑÏùò Î≥ÄÌòï Ï∂îÍ∞Ä (Îã§ÏñëÏÑ± ÌôïÎ≥¥)
            rgb_vector = add_color_variation(rgb_vector, emotion_data['colorCharacteristics'])
            
            X.append(face_vector)
            y.append(rgb_vector)
            emotions.append(emotion_name)
    
    return np.array(X, dtype=np.float32), np.array(y, dtype=np.float32), emotions

def generate_emotion_based_face_vector(emotion_name, emotion_data):
    """Í∞êÏ†ïÏóê Îî∞Î•∏ ÏñºÍµ¥ ÌäπÏßï Î≤°ÌÑ∞ ÏÉùÏÑ±"""
    # Í∏∞Î≥∏ 128Ï∞®Ïõê Î≤°ÌÑ∞ (Ï†ïÍ∑úÎ∂ÑÌè¨)
    face_vector = np.random.normal(0, 1, 128)
    
    # Í∞êÏ†ïÎ≥Ñ ÌäπÏÑ± Î∞òÏòÅ
    char = emotion_data['colorCharacteristics']
    
    if emotion_name == 'happy':
        # ÌñâÎ≥µ: Î∞ùÍ≥† ÌôúÍ∏∞Ï∞¨ ÌäπÏßï (ÏñëÏàò Ìé∏Ìñ•)
        face_vector = np.abs(face_vector) * 0.8 + 0.2
    elif emotion_name == 'sad':
        # Ïä¨Ìîî: Ïñ¥Îë°Í≥† Ï∞®Î∂ÑÌïú ÌäπÏßï (ÏùåÏàò Ìé∏Ìñ•)
        face_vector = -np.abs(face_vector) * 0.6 - 0.1
    elif emotion_name == 'angry':
        # Î∂ÑÎÖ∏: Í∞ïÎ†¨ÌïòÍ≥† ÎåÄÎπÑ ÎÜíÏùÄ ÌäπÏßï (Í∑πÍ∞í)
        face_vector = np.sign(face_vector) * np.power(np.abs(face_vector), 0.5)
    elif emotion_name == 'fearful':
        # ÎëêÎ†§ÏõÄ: Ï∞®Í∞ÄÏö¥ ÌäπÏßï (ÌäπÏ†ï Ï∞®Ïõê Í∞ïÏ°∞)
        face_vector[0:32] *= 1.5  # ÏïûÏ™Ω Ï∞®Ïõê Í∞ïÏ°∞
    elif emotion_name == 'disgusted':
        # ÌòêÏò§: ÌÉÅÌïú ÌäπÏßï (Ï§ëÍ∞ÑÍ∞í Ï§ëÏã¨)
        face_vector = np.tanh(face_vector) * 0.5
    elif emotion_name == 'surprised':
        # ÎÜÄÎûå: ÏÑ†Î™ÖÌïú ÌäπÏßï (Í≥†Ï£ºÌåå ÏÑ±Î∂Ñ)
        face_vector = face_vector * np.sin(np.linspace(0, 4*np.pi, 128))
    else:  # neutral
        # Ï§ëÎ¶Ω: Í∑†Ìòï Ïû°Ìûå ÌäπÏßï (Ï†ïÍ∑úÎ∂ÑÌè¨ Ïú†ÏßÄ)
        pass
    
    # Ï†ïÍ∑úÌôî
    face_vector = (face_vector - np.mean(face_vector)) / (np.std(face_vector) + 1e-8)
    
    return face_vector

def add_color_variation(rgb_vector, color_characteristics):
    """ÏÉâÏÉÅ Î≤°ÌÑ∞Ïóê Î≥ÄÌòï Ï∂îÍ∞Ä"""
    # Í∏∞Î≥∏ ÌäπÏÑ±Ïóê ÎßûÎäî ÎÖ∏Ïù¥Ï¶à Ï∂îÍ∞Ä
    brightness = color_characteristics['brightness']
    saturation = color_characteristics['saturation']
    temperature = color_characteristics['temperature']
    
    # Î∞ùÍ∏∞ Ï°∞Ï†ï
    rgb_vector = np.array(rgb_vector)
    rgb_vector = rgb_vector * brightness + (1 - brightness) * 0.1
    
    # Ï±ÑÎèÑ Ï°∞Ï†ï
    for i in range(0, len(rgb_vector), 3):
        r, g, b = rgb_vector[i:i+3]
        max_val = max(r, g, b)
        if max_val > 0:
            rgb_vector[i:i+3] = rgb_vector[i:i+3] * saturation + (1 - saturation) * max_val
    
    # ÏÉâÏò®ÎèÑ Ï°∞Ï†ï
    for i in range(0, len(rgb_vector), 3):
        r, g, b = rgb_vector[i:i+3]
        if temperature > 0:  # Îî∞ÎúªÌïú ÏÉâ
            rgb_vector[i] += temperature * 0.1  # R Ï¶ùÍ∞Ä
            rgb_vector[i+1] += temperature * 0.05  # G ÏïΩÍ∞Ñ Ï¶ùÍ∞Ä
            rgb_vector[i+2] -= temperature * 0.1  # B Í∞êÏÜå
        else:  # Ï∞®Í∞ÄÏö¥ ÏÉâ
            rgb_vector[i] -= abs(temperature) * 0.1  # R Í∞êÏÜå
            rgb_vector[i+1] -= abs(temperature) * 0.05  # G ÏïΩÍ∞Ñ Í∞êÏÜå
            rgb_vector[i+2] += abs(temperature) * 0.1  # B Ï¶ùÍ∞Ä
    
    # 0-1 Î≤îÏúÑÎ°ú ÌÅ¥Î¶¨Ìïë
    rgb_vector = np.clip(rgb_vector, 0, 1)
    
    return rgb_vector.tolist()

def augment_face_color_data(X, y, augmentation_factor=5):
    """ÏñºÍµ¥-ÏÉâÏÉÅ Îç∞Ïù¥ÌÑ∞ Ï¶ùÍ∞ï"""
    X_augmented = []
    y_augmented = []
    
    for i in range(len(X)):
        # ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
        X_augmented.append(X[i])
        y_augmented.append(y[i])
        
        # Ï¶ùÍ∞ï Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        for _ in range(augmentation_factor):
            # ÏñºÍµ¥ ÌäπÏßï Î≤°ÌÑ∞Ïóê ÎÖ∏Ïù¥Ï¶à Ï∂îÍ∞Ä
            face_noise = np.random.normal(0, 0.1, X[i].shape)
            face_augmented = np.clip(X[i] + face_noise, -3, 3)
            
            # ÏÉâÏÉÅ Î≤°ÌÑ∞Ïóê ÎÖ∏Ïù¥Ï¶à Ï∂îÍ∞Ä
            color_noise = np.random.normal(0, 0.05, y[i].shape)
            color_augmented = np.clip(y[i] + color_noise, 0, 1)
            
            X_augmented.append(face_augmented)
            y_augmented.append(color_augmented)
    
    return np.array(X_augmented, dtype=np.float32), np.array(y_augmented, dtype=np.float32)

def create_face_to_color_model(input_dim=128, output_dim=15):
    """ÏñºÍµ¥ ÌäπÏßïÏóêÏÑú ÏÉâÏÉÅÏúºÎ°ú Î≥ÄÌôòÌïòÎäî Î™®Îç∏ ÏÉùÏÑ±"""
    model = keras.Sequential([
        keras.layers.Dense(64, activation='relu', input_shape=(input_dim,)),
        keras.layers.BatchNormalization(),
        keras.layers.Dropout(0.2),
        keras.layers.Dense(32, activation='relu'),
        keras.layers.BatchNormalization(),
        keras.layers.Dropout(0.2),
        keras.layers.Dense(16, activation='relu'),
        keras.layers.Dropout(0.1),
        keras.layers.Dense(output_dim, activation='sigmoid')  # RGB Í∞íÏùÄ 0-1 Î≤îÏúÑ
    ])
    
    optimizer = keras.optimizers.Adam(learning_rate=0.001)
    
    model.compile(
        optimizer=optimizer,
        loss='mse',  # ÌöåÍ∑Ä Î¨∏Ï†úÏù¥ÎØÄÎ°ú MSE ÏÇ¨Ïö©
        metrics=['mae']
    )
    
    return model

def train_face_to_color_model(X, y):
    """ÏñºÍµ¥-ÏÉâÏÉÅ Î™®Îç∏ ÌïôÏäµ"""
    print("üß† ÏñºÍµ¥-ÏÉâÏÉÅ Î™®Îç∏ ÌïôÏäµ ÏãúÏûë...")
    
    model = create_face_to_color_model()
    
    # Î™®Îç∏ Íµ¨Ï°∞ Ï∂úÎ†•
    print(f"ÏûÖÎ†• Ï∞®Ïõê: {X.shape[1]}")
    print(f"Ï∂úÎ†• Ï∞®Ïõê: {y.shape[1]}")
    print(f"Ï¥ù ÏÉòÌîå Ïàò: {len(X)}")
    
    # Early stopping ÏΩúÎ∞±
    early_stopping = keras.callbacks.EarlyStopping(
        monitor='val_loss',
        patience=15,
        restore_best_weights=True,
        verbose=1
    )
    
    # ÌïôÏäµÎ•† Í∞êÏÜå ÏΩúÎ∞±
    reduce_lr = keras.callbacks.ReduceLROnPlateau(
        monitor='val_loss',
        factor=0.5,
        patience=8,
        min_lr=1e-7,
        verbose=1
    )
    
    # ÌïôÏäµ
    history = model.fit(
        X, y,
        epochs=100,
        batch_size=32,
        validation_split=0.2,
        callbacks=[early_stopping, reduce_lr],
        verbose=1
    )
    
    # ÏµúÏ¢Ö ÏÑ±Îä• Ï∂úÎ†•
    final_loss = history.history['loss'][-1]
    val_loss = history.history['val_loss'][-1]
    print(f"ÏµúÏ¢Ö ÌõàÎ†® ÏÜêÏã§: {final_loss:.6f}")
    print(f"ÏµúÏ¢Ö Í≤ÄÏ¶ù ÏÜêÏã§: {val_loss:.6f}")
    
    return model

def save_face_to_color_model_as_tfjs(model):
    """ÏñºÍµ¥-ÏÉâÏÉÅ Î™®Îç∏ÏùÑ TensorFlow.js ÌòïÏãùÏúºÎ°ú Ï†ÄÏû•"""
    # Î™®Îç∏ Ï†ÄÏû• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
    script_dir = os.path.dirname(os.path.abspath(__file__))
    model_dir = os.path.join(script_dir, "..", "public", "models", "face-to-color")
    model_dir = os.path.normpath(model_dir)
    
    # Í∏∞Ï°¥ ÎîîÎ†âÌÜ†Î¶¨ ÏÇ≠Ï†ú ÌõÑ Ïû¨ÏÉùÏÑ±
    import shutil
    if os.path.exists(model_dir):
        shutil.rmtree(model_dir)
    os.makedirs(model_dir, exist_ok=True)
    
    print(f"üîÑ ÏñºÍµ¥-ÏÉâÏÉÅ Î™®Îç∏ÏùÑ TensorFlow.js ÌòïÏãùÏúºÎ°ú Ï†ÄÏû• Ï§ë...")
    
    # 1. Î™®Îç∏ Íµ¨Ï°∞Î•º TensorFlow.js ÌòïÏãùÏúºÎ°ú Ï†ÄÏû•
    model_topology = model.to_json()
    model_config = json.loads(model_topology)
    
    # InputLayerÏùò batch_shapeÎ•º inputShapeÎ°ú Î≥ÄÌôò
    if 'config' in model_config and 'layers' in model_config['config']:
        for layer in model_config['config']['layers']:
            if (layer.get('module') == 'keras.layers' and 
                layer.get('class_name') == 'InputLayer'):
                layer_config = layer.get('config', {})
                if 'batch_shape' in layer_config:
                    batch_shape = layer_config['batch_shape']
                    if batch_shape and len(batch_shape) > 1:
                        layer_config['inputShape'] = batch_shape[1:]
                    del layer_config['batch_shape']
    
    # 2. Í∞ÄÏ§ëÏπò Ï∂îÏ∂ú Î∞è Ï†ÄÏû•
    weights = model.get_weights()
    weight_files = []
    
    for i, weight in enumerate(weights):
        weight_file = f"weights_{i}.bin"
        weight_path = os.path.join(model_dir, weight_file)
        weight.astype('float32').tofile(weight_path)
        weight_files.append(weight_file)
    
    # 3. Í∞ÄÏ§ëÏπò Îß§ÎãàÌéòÏä§Ìä∏ ÏÉùÏÑ±
    weights_manifest = [{
        "paths": weight_files,
        "weights": []
    }]
    
    # Í∞Å Í∞ÄÏ§ëÏπòÏóê ÎåÄÌïú ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
    weight_names = []
    for layer in model.layers:
        if hasattr(layer, 'kernel'):
            weight_names.append(f"{layer.name}/kernel")
            if layer.use_bias:
                weight_names.append(f"{layer.name}/bias")
        elif hasattr(layer, 'gamma'):
            # BatchNormalization Î†àÏù¥Ïñ¥
            weight_names.extend([
                f"{layer.name}/gamma",
                f"{layer.name}/beta", 
                f"{layer.name}/moving_mean",
                f"{layer.name}/moving_variance"
            ])
    
    for i, weight in enumerate(weights):
        weight_name = weight_names[i] if i < len(weight_names) else f"weight_{i}"
        weights_manifest[0]["weights"].append({
            "name": weight_name,
            "shape": list(weight.shape),
            "dtype": "float32"
        })
    
    # 4. model.json ÌååÏùº ÏÉùÏÑ±
    model_json = {
        "modelTopology": model_config,
        "weightsManifest": weights_manifest
    }
    
    with open(os.path.join(model_dir, 'model.json'), 'w') as f:
        json.dump(model_json, f, indent=2)
    
    # 5. Î™®Îç∏ Ï†ïÎ≥¥ Ï†ÄÏû•
    model_info = {
        'input_dim': 128,
        'output_dim': 15,
        'description': 'ÏñºÍµ¥ ÌäπÏßï Î≤°ÌÑ∞(128Ï∞®Ïõê)ÏóêÏÑú ÏÉâÏÉÅ ÌåîÎ†àÌä∏(15Ï∞®Ïõê)Î°ú Î≥ÄÌôòÌïòÎäî Î™®Îç∏',
        'emotions': ['happy', 'sad', 'angry', 'fearful', 'disgusted', 'surprised', 'neutral']
    }
    
    with open(os.path.join(model_dir, 'model_info.json'), 'w', encoding='utf-8') as f:
        json.dump(model_info, f, ensure_ascii=False, indent=2)
    
    print(f"‚úÖ ÏñºÍµ¥-ÏÉâÏÉÅ Î™®Îç∏Ïù¥ TensorFlow.js ÌòïÏãùÏúºÎ°ú {model_dir}Ïóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.")
    print(f"   üìÅ ÏÉùÏÑ±Îêú ÌååÏùº: model.json, {len(weight_files)}Í∞ú Í∞ÄÏ§ëÏπò ÌååÏùº, model_info.json")

def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    print("üöÄ ÏñºÍµ¥-ÏÉâÏÉÅ ÌåîÎ†àÌä∏ Î™®Îç∏ ÌïôÏäµ ÏãúÏûë!")
    print("üåê TensorFlow.js Î∏åÎùºÏö∞Ï†Ä Ìò∏Ìôò ÌòïÏãùÏúºÎ°ú Ï†ÄÏû•")
    
    # Í∞êÏ†ï-ÏÉâÏÉÅ Îß§Ìïë Î°úÎìú
    print("üìä Í∞êÏ†ï-ÏÉâÏÉÅ Îß§Ìïë Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ï§ë...")
    emotion_mapping = load_emotion_color_mapping()
    
    # Ìï©ÏÑ± Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    print("üîß Ìï©ÏÑ± ÏñºÍµ¥-ÏÉâÏÉÅ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± Ï§ë...")
    X, y, emotions = generate_synthetic_face_data(emotion_mapping, num_samples_per_emotion=30)
    print(f"   ÏÉùÏÑ±Îêú ÏÉòÌîå Ïàò: {len(X)}")
    print(f"   ÏûÖÎ†• Ï∞®Ïõê: {X.shape[1]}")
    print(f"   Ï∂úÎ†• Ï∞®Ïõê: {y.shape[1]}")
    
    # Îç∞Ïù¥ÌÑ∞ Ï¶ùÍ∞ï
    print("üîÑ Îç∞Ïù¥ÌÑ∞ Ï¶ùÍ∞ï Ï§ë...")
    X_augmented, y_augmented = augment_face_color_data(X, y, augmentation_factor=5)
    print(f"   Ï¶ùÍ∞ï ÌõÑ ÏÉòÌîå Ïàò: {len(X_augmented)}")
    
    # Î™®Îç∏ ÌïôÏäµ
    print("üß† Î™®Îç∏ ÌïôÏäµ ÏãúÏûë...")
    model = train_face_to_color_model(X_augmented, y_augmented)
    
    # TensorFlow.js ÌòïÏãùÏúºÎ°ú Ï†ÄÏû•
    print("üíæ TensorFlow.js ÌòïÏãùÏúºÎ°ú Ï†ÄÏû• Ï§ë...")
    save_face_to_color_model_as_tfjs(model)
    
    print("üéâ ÏñºÍµ¥-ÏÉâÏÉÅ Î™®Îç∏ ÌïôÏäµ Î∞è Ï†ÄÏû• ÏôÑÎ£å!")
    print("üåê Ïù¥Ï†ú Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Î∞îÎ°ú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§!")
    print("üìÅ ÏÉùÏÑ±Îêú ÌååÏùºÎì§:")
    print("   - model.json: TensorFlow.js Ìò∏Ìôò Î™®Îç∏ Íµ¨Ï°∞")
    print("   - weights_*.bin: Î™®Îç∏ Í∞ÄÏ§ëÏπò ÌååÏùºÎì§")
    print("   - model_info.json: Î™®Îç∏ Ï†ïÎ≥¥")

if __name__ == "__main__":
    main()
